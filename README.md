# Y2S1-Midterm

A cheatsheets repo for my friends.

**Disclaimer: Please take everything I say below with a grain of salt, and also do your own research. All lecturers have taught a lot of things in this semester. So, there might be some topics on the test that I forgot, choose to not include here, or just a pure speculation by me.**

Tip: Expose yourself to a lot of practice problems. So, below is a lot of practice problems for you to do!

**Please try them by yourself first.** Only after fighting bravely for 10 minutes, may you look at the solution.

Note: Important concepts/tools/weapons (whatever you'd like to call them, I like to use all three interchangebly) will be explained before their respective questions.

## Probability & Statistics (Maths but with a lot of counting)

- sample space
- events
- counting
- permutation
- combination
- probability
- conditional probability

## Linear Algebra (Maths about solving linear equations)

Tip: If you can prove the statements, you will gain a deeper understanding.

- matrix
- types
- row echelon form or not?
- gaussian elimination and gauss jordan
- transpose
- operations
- determinant

## Numerical Methods (Calculus x Programming)

Tip: If you can visualize it on a graph, you will find this subject easy. Bonus points if you can work it out in your head.

- root finding
- bisections

## Data Structures & Algorithms (Programming theories to prepare for an interview with Google)

Tip: To understand this subject, you need to stop thinking in Python and start thinking in C (a parent language of C++, not capable of OOP).
Or just think of it in pseudocode-style language, as long as it is not Python. 

Python is doing a lot of things for us, which makes it easier to translate our thought process. But this makes it harder to understand the real concepts. This is somewhat similiar to how when people have a shallow understanding of something, they tend to use complicate vocabularies to help them get their points across. Convenience is a bad thing here.

(python list meme)

Back then, when the computers were very bulky and very slow. DSAs are important because they speed up computations significantly. With a clever algorithm design, a O(n^2) process could be reduced to O(n) process. This is a huge deal. Because, with the same bulky and slow computer, a ~10000 seconds process would just shrink to a ~100 second process. Big difference.

(big com pic)

Nowaday, even with a very, very fast computer, the same reason for knowing DSAs still hold - to design a fast process that scale well with your inputs. Imagine a web developer making a website but it took 10 seconds to load, frustrating right?
Luckily, he knows DSAs. So, he took some time to review the code, spent a few days and nights optimizing, and now it only takes 0.1 seconds. :)

- runtime & complexities
- arrays
- queues
- stacks

